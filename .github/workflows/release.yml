name: Release Pipeline

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

env:
  NODE_VERSION: '20'

jobs:
  # Job 1: Create Release
  create-release:
    name: 🚀 Create Release
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 📦 Setup Node.js
        uses: actions/setup-node@v5
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: 🔧 Install dependencies
        run: npm ci

      - name: 🧪 Run tests
        run: npm test -- --watchAll=false

      - name: 🏗️ Build application
        run: npm run build
        env:
          BUILD_CONFIG: production
          RUNTIME_BASE_URL: /
          SASS_SILENCE_DEPRECATIONS: legacy-js-api

      - name: 🏷️ Generate tag (if workflow_dispatch)
        if: github.event_name == 'workflow_dispatch'
        run: |
          # Get current version from package.json
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "Current version: $CURRENT_VERSION"
          
          # Generate new version based on release type
          if [ "${{ github.event.inputs.release_type }}" == "major" ]; then
            NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{$1 = $1 + 1; $2 = 0; $3 = 0;} 1' OFS=.)
          elif [ "${{ github.event.inputs.release_type }}" == "minor" ]; then
            NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{$2 = $2 + 1; $3 = 0;} 1' OFS=.)
          else
            NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{$3 = $3 + 1;} 1' OFS=.)
          fi
          
          echo "New version: $NEW_VERSION"
          echo "NEW_VERSION=v$NEW_VERSION" >> $GITHUB_ENV
          
          # Update package.json version
          npm version $NEW_VERSION --no-git-tag-version
          
          # Create and push tag
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add package.json
          git commit -m "chore: bump version to $NEW_VERSION"
          git tag "v$NEW_VERSION"
          git push origin HEAD --tags

      - name: 🏷️ Get tag (if push)
        if: github.event_name == 'push'
        run: |
          TAG=${GITHUB_REF#refs/tags/}
          echo "NEW_VERSION=$TAG" >> $GITHUB_ENV

      - name: 📝 Generate changelog
        id: changelog
        run: |
          # Get previous tag for fallback
          PREV_TAG=$(git describe --abbrev=0 --tags $(git describe --abbrev=0 --tags)^ 2>/dev/null || echo "")
          
          # Try to get accumulated changeset first
          CHANGESET_BRANCH="changeset-accumulator"
          CHANGESET_FILE="PENDING_CHANGELOG.md"
          USED_ACCUMULATED_CHANGESET=false
          
          if git show-ref --verify --quiet refs/remotes/origin/$CHANGESET_BRANCH; then
            echo "📝 Found accumulated changeset, using it for release notes"
            
            # Fetch and checkout changeset branch
            git fetch origin $CHANGESET_BRANCH
            git checkout $CHANGESET_BRANCH
            
            if [ -f "$CHANGESET_FILE" ]; then
              echo "## 🚀 Release ${{ env.NEW_VERSION }}" > CHANGELOG.md
              echo "" >> CHANGELOG.md
              echo "$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> CHANGELOG.md
              echo "" >> CHANGELOG.md
              
              # Extract the changes section from accumulated changeset
              sed -n '/## 📝 Changes by Category/,/^---$/p' "$CHANGESET_FILE" | head -n -1 >> CHANGELOG.md
              
              # Add release metadata
              echo "" >> CHANGELOG.md
              echo "---" >> CHANGELOG.md
              echo "" >> CHANGELOG.md
              echo "## 📊 Release Information" >> CHANGELOG.md
              echo "- **Version**: ${{ env.NEW_VERSION }}" >> CHANGELOG.md
              echo "- **Previous Version**: ${PREV_TAG:-"Initial Release"}" >> CHANGELOG.md
              echo "- **Release Date**: $(date -u '+%Y-%m-%d')" >> CHANGELOG.md
              echo "- **Build Configuration**: Production" >> CHANGELOG.md
              echo "" >> CHANGELOG.md
              echo "## 📦 Assets" >> CHANGELOG.md
              echo "- **Build artifacts**: Available in the release assets" >> CHANGELOG.md
              echo "- **Source code**: Available as zip and tar.gz" >> CHANGELOG.md
              
              USED_ACCUMULATED_CHANGESET=true
              echo "✅ Successfully used accumulated changeset for release notes"
            else
              echo "⚠️ Changeset file not found, falling back to git log"
            fi
            
            # Return to main branch
            git checkout main
          else
            echo "📋 No accumulated changeset found, using git log fallback"
          fi
          
          # Fallback to git log if no accumulated changeset
          if [ "$USED_ACCUMULATED_CHANGESET" = "false" ]; then
            if [ -z "$PREV_TAG" ]; then
              echo "## 🎉 Initial Release ${{ env.NEW_VERSION }}" > CHANGELOG.md
              echo "" >> CHANGELOG.md
              echo "This is the first release of Opinion Front UI!" >> CHANGELOG.md
            else
              echo "## 🚀 Changes from $PREV_TAG to ${{ env.NEW_VERSION }}" > CHANGELOG.md
              echo "" >> CHANGELOG.md
              
              # Generate changelog from commits
              git log $PREV_TAG..HEAD --oneline --pretty=format:"- %s" >> CHANGELOG.md
            fi
            
            echo "" >> CHANGELOG.md
            echo "## 📦 Assets" >> CHANGELOG.md
            echo "- **Build artifacts**: Available in the release assets" >> CHANGELOG.md
            echo "- **Source code**: Available as zip and tar.gz" >> CHANGELOG.md
          fi
          
          # Store whether we used accumulated changeset for cleanup step
          echo "used_accumulated_changeset=$USED_ACCUMULATED_CHANGESET" >> $GITHUB_OUTPUT

      - name: 📦 Create release archive
        run: |
          # Create release archive with built assets
          tar -czf opinion-front-ui-${{ env.NEW_VERSION }}.tar.gz dist/
          zip -r opinion-front-ui-${{ env.NEW_VERSION }}.zip dist/

      - name: 🎉 Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.NEW_VERSION }}
          name: Opinion Front UI ${{ env.NEW_VERSION }}
          body_path: CHANGELOG.md
          draft: false
          prerelease: false
          files: |
            opinion-front-ui-${{ env.NEW_VERSION }}.tar.gz
            opinion-front-ui-${{ env.NEW_VERSION }}.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 🔍 Verify build output
        run: |
          echo "Verifying build output..."
          ls -la dist/
          echo "Build configuration used: production"
          echo "Runtime base URL: /"
          
          # Check if main files exist
          if [ ! -f "dist/index.html" ]; then
            echo "ERROR: index.html not found in dist/"
            exit 1
          fi
          
          # Check if build includes the production config
          if grep -q "__BUILD_CONFIG__" dist/assets/*.js; then
            echo "✅ Build configuration properly embedded"
          else
            echo "⚠️ Warning: Build configuration not found in bundle"
          fi

      - name: 🧹 Cleanup Changeset (after successful release)
        if: steps.changelog.outputs.used_accumulated_changeset == 'true'
        run: |
          echo "🧹 Cleaning up accumulated changeset after successful release"
          
          CHANGESET_BRANCH="changeset-accumulator"
          CHANGESET_FILE="PENDING_CHANGELOG.md"
          
          # Setup git configuration
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Checkout changeset branch
          git fetch origin $CHANGESET_BRANCH
          git checkout $CHANGESET_BRANCH
          
          # Reset the changeset file
          cat > $CHANGESET_FILE << 'EOF'
          # 📋 Pending Release Changelog
          
          This file accumulates changes that will be included in the next release.
          It is automatically maintained by the Changeset Accumulator workflow.
          
          ## 📊 Summary
          - **Total Commits**: 0
          - **Last Updated**: Never
          - **Next Release**: TBD
          - **Previous Release**: ${{ env.NEW_VERSION }}
          
          ---
          
          ## 📝 Changes by Category
          
          _No changes yet._
          
          ---
          
          ⚠️ **Note**: This file is automatically generated. Do not edit manually.
          EOF
          
          # Commit and push the reset changeset
          git add $CHANGESET_FILE
          git commit -m "🧹 Reset changeset after release ${{ env.NEW_VERSION }}"
          git push origin $CHANGESET_BRANCH
          
          echo "✅ Changeset cleared for next release cycle"
          
          # Return to main branch
          git checkout main

      - name: 📢 Release Summary
        run: |
          echo "## 🎉 Release ${{ env.NEW_VERSION }} Created Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📊 Release Details:" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ env.NEW_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Config**: Production" >> $GITHUB_STEP_SUMMARY
          echo "- **Base URL**: /" >> $GITHUB_STEP_SUMMARY
          echo "- **Release URL**: https://github.com/${{ github.repository }}/releases/tag/${{ env.NEW_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Status**: ✅ Successful" >> $GITHUB_STEP_SUMMARY
          echo "- **Assets**: Archive files uploaded" >> $GITHUB_STEP_SUMMARY
          echo "- **Changeset**: ${{ steps.changelog.outputs.used_accumulated_changeset == 'true' && '✅ Used accumulated changeset and cleared it' || '📋 Used git log fallback' }}" >> $GITHUB_STEP_SUMMARY
